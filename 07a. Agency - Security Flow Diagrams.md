# Agency â€“ Security Encryption Flow Diagrams

This document provides detailed sequence diagrams for each major user flow in Agency, highlighting:
- ğŸ” **Encrypted data** at each step
- ğŸš« **Zero-knowledge boundaries** (where servers cannot decrypt)
- ğŸ›¡ï¸ **Security mechanisms** and privacy guarantees

---

## Table of Contents

1. [Key Management Initialization](#1-key-management--initialization)
2. [Document Ingestion - Standalone Mode](#2-document-ingestion---standalone-mode)
3. [Document Ingestion - App-Managed Storage](#3-document-ingestion---app-managed-storage)
4. [Document Ingestion - BYOS Storage](#4-document-ingestion---byos-storage)
5. [Search RAG Chat - Standalone](#5-search--rag-chat---standalone)
6. [Search RAG Chat - Cloud-Connected](#6-search--rag-chat---cloud-connected)
7. [Document Download Decryption](#7-document-download--decryption)
8. [Share Link Creation Access](#8-share-link-creation--access)
9. [Team Creation Key Distribution](#9-team-creation--key-distribution)
10. [TEE Offload/Load Flow](#10-tee-offloadload-flow)

---

## Legend

```mermaid
flowchart LR
    subgraph "Trust Boundaries"
        T1[ğŸŸ¢ Trusted Zone<br/>User's Device]
        T2[ğŸŸ¡ Semi-Trusted<br/>TEE/Enclave]
        T3[ğŸ”´ Untrusted<br/>Cloud Storage]
    end
    
    subgraph "Data States"
        D1[ğŸ“„ Plaintext Data]
        D2[ğŸ” Encrypted Data]
        D3[ğŸ”‘ Encryption Keys]
        D4[ğŸ“Š Metadata Only]
    end
```

> **Zero-Knowledge Principle:** In all flows, the cloud infrastructure (Go API, Supabase, S3 storage) only sees:
> - ğŸ” Encrypted blobs
> - ğŸ” Encrypted filenames (hex-encoded)
> - ğŸ“Š Non-sensitive metadata (IDs, timestamps, sizes)
> - âŒ **Never** plaintext content, filenames, or decryption keys

---

## 1. Key Management Initialization

### User Master Key Generation

```mermaid
sequenceDiagram
    participant User
    participant TauriApp as ğŸŸ¢ Tauri App
    participant PyBackend as ğŸŸ¢ Python Backend
    participant LocalVault as ğŸŸ¢ Encrypted Vault

    Note over User,LocalVault: ğŸŸ¢ ALL IN TRUSTED ZONE (User's Device)
    
    User->>TauriApp: First launch
    TauriApp->>PyBackend: Initialize crypto system
    
    rect rgb(245, 245, 245)
        Note over PyBackend: Key Generation (Local Only)
        PyBackend->>PyBackend: Generate ğŸ”‘ User Master Key<br/>(AES-256 / XChaCha20-Poly1305)
        PyBackend->>PyBackend: Derive salt + KDF params
        PyBackend->>LocalVault: Store ğŸ” Encrypted Master Key<br/>(protected by user password/biometric)
    end
    
    PyBackend-->>TauriApp: âœ… Crypto initialized
    TauriApp-->>User: Ready to use
    
    Note over LocalVault: ğŸ”‘ User Master Key NEVER leaves device
    Note over LocalVault: Used to encrypt/decrypt org team keys
```

**Security Properties:**
- ğŸ”‘ User Master Key generated locally using secure random number generator
- ğŸ” Protected by user password or biometric authentication
- ğŸš« **Zero-Knowledge Boundary:** Master key NEVER transmitted to cloud
- ğŸ’¾ Stored in encrypted local vault (filesystem encryption)

---

## 2. Document Ingestion - Standalone Mode

```mermaid
sequenceDiagram
    participant User
    participant TauriApp as ğŸŸ¢ Tauri App
    participant PyBackend as ğŸŸ¢ Python Backend
    participant Postgres as ğŸŸ¢ Local Postgres
    participant Qdrant as ğŸŸ¢ Local Qdrant
    participant Neo4j as ğŸŸ¢ Local Neo4j
    participant Vault as ğŸŸ¢ Encrypted Vault

    Note over User,Vault: ğŸŸ¢ 100% LOCAL - FULLY OFFLINE CAPABLE
    
    User->>TauriApp: Drag drop ğŸ“„ document.pdf
    TauriApp->>PyBackend: POST /ingest (file path)
    
    rect rgb(245, 245, 245)
        Note over PyBackend: Document Processing Pipeline
        
        PyBackend->>PyBackend: 1ï¸âƒ£ Parse document<br/>(extract text, tables, metadata)
        Note over PyBackend: ğŸ“„ Plaintext exists ONLY in memory
        
        PyBackend->>PyBackend: 2ï¸âƒ£ Chunk text by title strategy
        
        PyBackend->>PyBackend: 3ï¸âƒ£ Generate embeddings<br/>(local LLM model)
        
        PyBackend->>PyBackend: 4ï¸âƒ£ Extract entities relationships<br/>(NER for people, orgs, events)
        
        PyBackend->>PyBackend: 5ï¸âƒ£ Get ğŸ”‘ Team Key from memory
        PyBackend->>PyBackend: 6ï¸âƒ£ Encrypt original file<br/>ğŸ” AES-256-CBC(Team Key, file)
        PyBackend->>PyBackend: 7ï¸âƒ£ Encrypt filename<br/>ğŸ” hex(encrypt(Team Key, "document.pdf"))
    end
    
    rect rgb(240, 242, 245)
        Note over PyBackend,Vault: Persistence Layer
        
        PyBackend->>Postgres: Store document metadata<br/>ğŸ“Š {id, ğŸ”encrypted_filename, size, created_at}
        PyBackend->>Postgres: Store ğŸ“„ plaintext chunks<br/>(searchable, team-scoped)
        
        PyBackend->>Qdrant: Store vector embeddings<br/>(collection per team)
        
        PyBackend->>Neo4j: Store entities relations<br/>(graph nodes, team-scoped)
        
        PyBackend->>Vault: Store ğŸ” encrypted file blob<br/>(original document encrypted)
    end
    
    PyBackend-->>TauriApp: âœ… Ingestion complete
    TauriApp-->>User: Document added to knowledge base
    
    Note over Postgres,Vault: ğŸ“„ Plaintext chunks in local DBs for search<br/>ğŸ” Original file encrypted in vault<br/>ğŸš« NO cloud transmission in standalone mode
```

**Security Properties:**
- ğŸ“„ Plaintext exists ONLY in memory during processing
- ğŸ” Original file encrypted with team key before storage
- ğŸ“„ Text chunks stored in plaintext locally for search (team-scoped)
- ğŸŸ¢ All data stays on user's device
- ğŸš« **Zero-Knowledge Boundary:** Not applicable (no cloud in standalone mode)
- ğŸ’¾ Encrypted vault protects original files at rest

**Privacy Guarantees:**
- âœ… Fully offline capable - no network calls required
- âœ… Local search and embeddings - no data leaves device
- âœ… Multi-team isolation via local database scoping

---

## 3. Document Ingestion - App-Managed Storage

```mermaid
sequenceDiagram
    participant User
    participant TauriApp as ğŸŸ¢ Tauri App
    participant PyBackend as ğŸŸ¢ Python Backend
    participant LocalDBs as ğŸŸ¢ Local DBs<br/>(Postgres/Qdrant/Neo4j)
    participant GoAPI as ğŸ”´ Go API<br/>(api.getagency.app)
    participant Supabase as ğŸ”´ Supabase
    participant S3 as ğŸ”´ App-Managed S3<br/>(Wasabi/Backblaze)

    Note over User,LocalDBs: ğŸŸ¢ TRUSTED ZONE
    Note over GoAPI,S3: ğŸ”´ UNTRUSTED ZONE (Zero-Knowledge Boundary)
    
    User->>TauriApp: Upload document.pdf
    TauriApp->>PyBackend: POST /ingest
    
    rect rgb(245, 245, 245)
        Note over PyBackend: Local Processing (Same as Standalone)
        PyBackend->>PyBackend: 1ï¸âƒ£ Parse, chunk, embed, extract entities
        PyBackend->>LocalDBs: 2ï¸âƒ£ Store chunks, vectors, graph locally
        PyBackend->>PyBackend: 3ï¸âƒ£ Get ğŸ”‘ Team Key from session
    end
    
    rect rgb(245, 242, 240)
        Note over PyBackend,S3: ğŸš« ZERO-KNOWLEDGE UPLOAD
        
        PyBackend->>PyBackend: 4ï¸âƒ£ Encrypt file<br/>ğŸ” ciphertext = AES-256-CBC(ğŸ”‘Team Key, file)
        PyBackend->>PyBackend: 5ï¸âƒ£ Encrypt filename<br/>ğŸ” enc_name = hex(encrypt(ğŸ”‘Team Key, "document.pdf"))
        
        PyBackend->>GoAPI: POST /upload/initiate<br/>ğŸ“Š {team_id, ğŸ”enc_filename, size, mime_type}
        Note over GoAPI: Sees ONLY encrypted filename
        
        GoAPI->>Supabase: Check permissions quota
        Supabase-->>GoAPI: âœ… Authorized
        
        GoAPI->>GoAPI: Generate presigned S3 URL<br/>(App-Managed bucket)
        GoAPI-->>PyBackend: {presigned_url, file_id}
        
        PyBackend->>S3: PUT ğŸ” encrypted_blob<br/>(directly to S3)
        Note over S3: Stores ONLY ciphertext
        S3-->>PyBackend: âœ… Upload complete
        
        PyBackend->>GoAPI: POST /upload/complete<br/>ğŸ“Š {file_id, checksum}
        GoAPI->>Supabase: Record file metadata<br/>ğŸ“Š {id, team_id, ğŸ”enc_filename, size, created_at}
    end
    
    PyBackend-->>TauriApp: âœ… Sync complete
    TauriApp-->>User: Document synced to cloud
    
    Note over S3: ğŸ” Only encrypted blob stored<br/>ğŸ” Filename is encrypted hex-encoded<br/>ğŸš« Cloud CANNOT decrypt without Team Key
    Note over GoAPI,Supabase: ğŸ”´ ZERO-KNOWLEDGE: No plaintext access<br/>ğŸ”‘ Team Key never transmitted
```

**Security Properties:**
- ğŸ” File encrypted with team key BEFORE leaving device
- ğŸ” Filename encrypted and hex-encoded before transmission
- ğŸ”‘ Team key NEVER sent to cloud (stays in local memory)
- ğŸ“Š Cloud sees only: encrypted blob, encrypted filename, metadata (size, timestamps)
- ğŸš« **Zero-Knowledge Boundary:** Go API, Supabase, and S3 cannot decrypt content

**Data Flow:**
1. ğŸŸ¢ **Trusted:** Processing and encryption on local device
2. ğŸ”´ **Untrusted:** Encrypted upload to cloud storage
3. ğŸ”´ **Untrusted:** Cloud stores ciphertext only

---

## 4. Document Ingestion - BYOS Storage

```mermaid
sequenceDiagram
    participant User
    participant TauriApp as ğŸŸ¢ Tauri App
    participant PyBackend as ğŸŸ¢ Python Backend
    participant LocalDBs as ğŸŸ¢ Local DBs
    participant GoAPI as ğŸ”´ Go API
    participant Supabase as ğŸ”´ Supabase
    participant UserS3 as ğŸ”´ User's S3 Bucket<br/>(AWS/GCP/Azure/R2)

    Note over User,LocalDBs: ğŸŸ¢ TRUSTED ZONE
    Note over GoAPI,UserS3: ğŸ”´ UNTRUSTED ZONE (User-Controlled Storage)
    
    User->>TauriApp: Upload document.pdf
    TauriApp->>PyBackend: POST /ingest
    
    rect rgb(245, 245, 245)
        Note over PyBackend: Local Processing
        PyBackend->>PyBackend: 1ï¸âƒ£ Parse, chunk, embed, NER
        PyBackend->>LocalDBs: 2ï¸âƒ£ Store locally
        PyBackend->>PyBackend: 3ï¸âƒ£ Get ğŸ”‘ Team Key
    end
    
    rect rgb(245, 242, 240)
        Note over PyBackend,UserS3: BYOS Upload Flow
        
        PyBackend->>PyBackend: 4ï¸âƒ£ Encrypt file + filename<br/>ğŸ” AES-256-CBC(ğŸ”‘Team Key, data)
        
        PyBackend->>GoAPI: GET /storage/byos/credentials<br/>ğŸ“Š {org_id, team_id}
        
        GoAPI->>Supabase: Fetch ğŸ” encrypted BYOS credentials
        Note over Supabase: Credentials encrypted with ğŸ”‘ Org Key
        
        GoAPI->>GoAPI: Get ğŸ” encrypted credentials<br/>(still encrypted)
        GoAPI-->>PyBackend: {ğŸ”encrypted_credentials, provider, bucket}
        
        PyBackend->>PyBackend: Decrypt credentials locally<br/>ğŸ”‘ Org Key (from session)
        Note over PyBackend: ğŸ”‘ Plaintext credentials ONLY in local memory
        
        PyBackend->>PyBackend: Initialize provider SDK<br/>(AWS/Azure/GCP/S3-compatible)
        
        PyBackend->>UserS3: PUT ğŸ” encrypted_blob<br/>(using user's bucket)
        Note over UserS3: User owns controls storage
        UserS3-->>PyBackend: âœ… Upload complete
        
        PyBackend->>GoAPI: POST /files/register<br/>ğŸ“Š {team_id, ğŸ”enc_filename, size, storage_path}
        GoAPI->>Supabase: Record file metadata
    end
    
    PyBackend-->>TauriApp: âœ… Synced to BYOS
    TauriApp-->>User: Document in your bucket
    
    Note over UserS3: ğŸ” User controls storage retention<br/>ğŸ” Only encrypted data stored<br/>ğŸ”‘ Agency never stores plaintext credentials
    Note over GoAPI: ğŸ”´ Cloud stores encrypted credentials<br/>ğŸ”‘ Decryption happens locally only
```

**Security Properties:**
- ğŸ” File and filename encrypted before upload
- ğŸ”‘ BYOS credentials encrypted with org key in cloud
- ğŸ”‘ Credentials decrypted ONLY in local backend (never in cloud)
- ğŸ¢ User owns and controls the storage bucket
- ğŸš« **Zero-Knowledge Boundary:** Cloud API never sees plaintext credentials or file content
- ğŸ” Provider SDK initialized locally with decrypted credentials

**BYOS Advantages:**
- âœ… User controls data residency and retention policies
- âœ… Direct control over storage costs and lifecycle
- âœ… Credentials protected via org key encryption
- âœ… Agency cloud never handles plaintext storage credentials

---

## 5. Search RAG Chat - Standalone

```mermaid
sequenceDiagram
    participant User
    participant TauriApp as ğŸŸ¢ Tauri App
    participant PyBackend as ğŸŸ¢ Python Backend
    participant Postgres as ğŸŸ¢ Postgres
    participant Qdrant as ğŸŸ¢ Qdrant
    participant Neo4j as ğŸŸ¢ Neo4j
    participant LLM as ğŸŸ¢ Local LLM

    Note over User,LLM: ğŸŸ¢ 100% LOCAL - FULLY PRIVATE
    
    User->>TauriApp: Search: "Q3 budget overruns"
    TauriApp->>PyBackend: POST /search<br/>ğŸ“Š {query, team_id, filters}
    
    rect rgb(245, 245, 245)
        Note over PyBackend: Hybrid Search Pipeline
        
        PyBackend->>PyBackend: 1ï¸âƒ£ Generate query embedding<br/>(local model)
        
        par Parallel Search
            PyBackend->>Postgres: Keyword metadata search<br/>ğŸ“Š (team-scoped)
            Postgres-->>PyBackend: Matching ğŸ“„ chunks
        and
            PyBackend->>Qdrant: Vector similarity search<br/>ğŸ“Š (team collection)
            Qdrant-->>PyBackend: Similar ğŸ“„ chunks
        and
            PyBackend->>Neo4j: Graph query for related entities<br/>ğŸ“Š (team graph)
            Neo4j-->>PyBackend: Related entities
        end
        
        PyBackend->>PyBackend: 2ï¸âƒ£ Merge rank results
        PyBackend->>PyBackend: 3ï¸âƒ£ Group by document
    end
    
    PyBackend-->>TauriApp: ğŸ“„ Search results with citations
    TauriApp-->>User: Shows documents relevant passages
    
    User->>TauriApp: Chat: "Summarize the budget issues"
    TauriApp->>PyBackend: POST /chat<br/>ğŸ“Š {message, team_id, context}
    
    rect rgb(243, 245, 243)
        Note over PyBackend,LLM: RAG Chat Pipeline
        
        PyBackend->>PyBackend: 1ï¸âƒ£ Retrieve relevant chunks<br/>(same hybrid search)
        
        PyBackend->>PyBackend: 2ï¸âƒ£ Build RAG prompt<br/>ğŸ“„ Context: {chunks}<br/>ğŸ“„ Question: {message}
        
        PyBackend->>LLM: Generate response<br/>(local LLM in memory)
        Note over LLM: Model downloaded managed by app
        
        LLM-->>PyBackend: ğŸ“„ Generated answer + sources
        
        PyBackend->>Postgres: Save to ğŸ“Š query_history<br/>(team-scoped)
    end
    
    PyBackend-->>TauriApp: ğŸ“„ Answer with document citations
    TauriApp-->>User: Shows AI response with sources
    
    Note over PyBackend,LLM: ğŸš« Zero external API calls<br/>ğŸ”‘ All data stays on device<br/>ğŸŸ¢ Works fully offline
```

**Security Properties:**
- ğŸŸ¢ All processing happens locally on user's device
- ğŸ“„ Search operates on plaintext chunks (team-scoped in local DB)
- ğŸ¤– Local LLM model (no external AI API calls)
- ğŸš« **Zero-Knowledge Boundary:** Not applicable (fully local)
- ğŸ”’ Team isolation via database scoping

**Privacy Guarantees:**
- âœ… No network calls - fully offline capable
- âœ… No telemetry or analytics sent to cloud
- âœ… Query history stored locally only
- âœ… Complete data privacy

---

## 6. Search RAG Chat - Cloud-Connected

```mermaid
sequenceDiagram
    participant User
    participant TauriApp as ğŸŸ¢ Tauri App
    participant PyBackend as ğŸŸ¢ Python Backend
    participant LocalDBs as ğŸŸ¢ Local DBs<br/>(Postgres/Qdrant/Neo4j)
    participant GoAPI as ğŸ”´ Go API
    participant Supabase as ğŸ”´ Supabase

    Note over User,LocalDBs: ğŸŸ¢ TRUSTED ZONE (All Content Processing)
    Note over GoAPI,Supabase: ğŸ”´ UNTRUSTED ZONE (Metadata Only)
    
    User->>TauriApp: Search Chat query
    TauriApp->>PyBackend: POST /search or /chat
    
    rect rgb(245, 245, 245)
        Note over PyBackend,LocalDBs: Search RAG (100% Local)
        
        PyBackend->>LocalDBs: Hybrid search (keyword + vector + graph)
        LocalDBs-->>PyBackend: ğŸ“„ Matching chunks
        
        PyBackend->>PyBackend: Generate embeddings RAG response<br/>(local LLM)
        
        PyBackend->>LocalDBs: Save ğŸ“Š query_history locally
    end
    
    opt Cloud Sync (Optional Background)
        PyBackend->>GoAPI: POST /analytics/query-log<br/>ğŸ“Š {team_id, query_hash, timestamp}
        Note over GoAPI: Receives ONLY anonymized metadata<br/>âŒ NO query text, results, or content
        
        GoAPI->>Supabase: Store usage stats<br/>ğŸ“Š {query_count, team_id, date}
        Note over Supabase: For billing org analytics only
    end
    
    PyBackend-->>TauriApp: ğŸ“„ Search results / chat response
    TauriApp-->>User: Display results
    
    Note over LocalDBs: ğŸŸ¢ ALL content processing local<br/>ğŸ“„ Plaintext chunks never leave device<br/>ğŸ¤– LLM runs locally
    Note over GoAPI,Supabase: ğŸ”´ Cloud sees ONLY:<br/>ğŸ“Š Usage counts timestamps<br/>âŒ NO query content or results
```

**Security Properties:**
- ğŸŸ¢ Search and RAG processing identical to standalone (100% local)
- ğŸ“Š Optional usage telemetry (anonymized, no content)
- ğŸ”‘ Query text and results NEVER sent to cloud
- ğŸš« **Zero-Knowledge Boundary:** Cloud cannot see queries or search results
- ğŸ“ˆ Usage stats for billing purposes only

**What Cloud Sees:**
- âœ… Number of queries per team
- âœ… Timestamps and usage patterns
- âŒ **Never:** Query text, search results, document content

---

## 7. Document Download Decryption

```mermaid
sequenceDiagram
    participant User
    participant TauriApp as ğŸŸ¢ Tauri App
    participant PyBackend as ğŸŸ¢ Python Backend
    participant LocalCache as ğŸŸ¢ Local Cache
    participant GoAPI as ğŸ”´ Go API
    participant Supabase as ğŸ”´ Supabase
    participant S3 as ğŸ”´ Cloud Storage<br/>(App-Managed or BYOS)

    Note over User,LocalCache: ğŸŸ¢ TRUSTED ZONE
    Note over GoAPI,S3: ğŸ”´ UNTRUSTED ZONE
    
    User->>TauriApp: Open document "report.pdf"
    TauriApp->>PyBackend: GET /documents/{id}/content
    
    PyBackend->>LocalCache: Check local vault
    
    alt Document cached locally
        LocalCache-->>PyBackend: ğŸ” Encrypted blob (cached)
    else Need to download
        rect rgb(245, 242, 240)
            Note over PyBackend,S3: Authenticated Download
            
            PyBackend->>GoAPI: GET /files/{file_id}/download-url<br/>ğŸ“Š {team_id, file_id}
            
            GoAPI->>Supabase: Verify permissions<br/>ğŸ“Š Check team membership
            Supabase-->>GoAPI: âœ… User authorized
            
            GoAPI->>GoAPI: Generate time-limited presigned URL<br/>(or CF Worker auth token)
            GoAPI-->>PyBackend: {download_url, ğŸ”enc_filename}
            
            PyBackend->>S3: GET ğŸ” encrypted_blob<br/>(using presigned URL)
            Note over S3: Downloads ciphertext
            S3-->>PyBackend: ğŸ” Encrypted file
            
            PyBackend->>LocalCache: Cache ğŸ” encrypted blob locally
        end
    end
    
    rect rgb(245, 245, 245)
        Note over PyBackend: Client-Side Decryption
        
        PyBackend->>PyBackend: Get ğŸ”‘ Team Key from session
        PyBackend->>PyBackend: Decrypt file<br/>ğŸ“„ plaintext = AES-256-CBC-decrypt(ğŸ”‘Team Key, ğŸ”blob)
        PyBackend->>PyBackend: Decrypt filename<br/>ğŸ“„ "report.pdf" = decrypt(ğŸ”‘Team Key, ğŸ”enc_name)
        
        Note over PyBackend: ğŸ“„ Plaintext exists ONLY in memory
    end
    
    PyBackend-->>TauriApp: ğŸ“„ Plaintext file content
    TauriApp-->>User: Display document
    
    Note over S3: ğŸ” Only ciphertext transmitted<br/>ğŸš« Cloud never sees plaintext
    Note over PyBackend: ğŸ”‘ Decryption happens locally<br/>ğŸ”‘ Team Key never sent to cloud
```

**Security Properties:**
- ğŸ” Cloud storage serves only encrypted blobs
- ğŸ”‘ Decryption happens exclusively in local backend
- ğŸ”‘ Team key stays in local memory (never transmitted)
- ğŸ”’ Presigned URLs are time-limited and permission-checked
- ğŸš« **Zero-Knowledge Boundary:** Cloud cannot decrypt files

**Download Flow:**
1. ğŸ”´ **Untrusted:** Download encrypted blob from cloud
2. ğŸŸ¢ **Trusted:** Decrypt locally with team key
3. ğŸ“„ **Plaintext:** Exists only in local memory/cache

---

## 8. Share Link Creation Access

```mermaid
sequenceDiagram
    participant Owner as ğŸŸ¢ Document Owner
    participant PyBackend as ğŸŸ¢ Python Backend
    participant GoAPI as ğŸ”´ Go API
    participant Supabase as ğŸ”´ Supabase
    participant ShareWorker as ğŸ”´ CF Worker<br/>(shares.getagency.app)
    participant Recipient as ğŸ”µ Share Recipient
    participant RecipientApp as ğŸŸ¢ Recipient's App

    Note over Owner,PyBackend: ğŸŸ¢ OWNER'S DEVICE
    Note over GoAPI,ShareWorker: ğŸ”´ UNTRUSTED CLOUD
    Note over Recipient,RecipientApp: ğŸŸ¢ RECIPIENT'S DEVICE
    
    Owner->>PyBackend: Create share link for document
    
    rect rgb(245, 245, 245)
        Note over PyBackend: Share Link Generation
        
        PyBackend->>PyBackend: Get ğŸ”‘ Team Key
        PyBackend->>PyBackend: Generate random ğŸ”‘ Share Key
        PyBackend->>PyBackend: Encrypt document<br/>ğŸ” share_cipher = encrypt(ğŸ”‘Share Key, file)
        PyBackend->>PyBackend: Optional: encrypt with password<br/>ğŸ” password_wrapped_key
    end
    
    PyBackend->>GoAPI: POST /shares/create<br/>ğŸ“Š {file_id, ğŸ”share_cipher_ref, expiry, password_hash}
    
    GoAPI->>Supabase: Store share metadata<br/>ğŸ“Š {share_id, file_id, expiry, password_hash, access_count}
    Note over Supabase: NO encryption keys stored<br/>Only metadata password hash
    
    GoAPI-->>PyBackend: {share_url: "shares.getagency.app/{share_id}"}
    PyBackend->>PyBackend: Append ğŸ”‘ Share Key to URL fragment<br/>(shares.getagency.app/{id}#key={share_key})
    
    PyBackend-->>Owner: ğŸ”— Share URL with key in fragment
    Owner->>Recipient: Send share link
    
    rect rgb(240, 242, 245)
        Note over Recipient,RecipientApp: Share Link Access
        
        Recipient->>ShareWorker: Open shares.getagency.app/{id}#key=...
        Note over ShareWorker: Fragment (#key=...) NOT sent to server<br/>(stays in browser)
        
        ShareWorker->>Supabase: GET /shares/{id}/metadata
        Supabase-->>ShareWorker: ğŸ“Š {expiry, password_required, file_ref}
        
        alt Password protected
            ShareWorker->>Recipient: Prompt for password
            Recipient->>ShareWorker: Enter password
            ShareWorker->>Supabase: Verify password hash
        end
        
        ShareWorker->>Supabase: Log access<br/>ğŸ“Š {share_id, timestamp, IP_hash}
        
        alt App-Managed Storage
            ShareWorker-->>Recipient: HTML page with download button
            Note over Recipient: ğŸ”‘ Share Key from URL fragment (in browser memory only)
            
            Recipient->>ShareWorker: Click download
            ShareWorker->>GoAPI: Generate presigned URL for ğŸ” share_cipher
            GoAPI-->>ShareWorker: {download_url}
            
            Recipient->>ShareWorker: Download ğŸ” encrypted blob
            
            Note over Recipient: Client-side decryption in browser
            Recipient->>Recipient: JavaScript: decrypt(ğŸ”‘Share Key, ğŸ”blob)
            Recipient->>Recipient: Download ğŸ“„ plaintext file
            
        else BYOS Storage
            ShareWorker-->>Recipient: Deep link to app<br/>agency://open-share/{id}#key=...
            Recipient->>RecipientApp: Open in Agency app (if registered user)
            RecipientApp->>RecipientApp: Decrypt with ğŸ”‘ Share Key
        end
    end
    
    Note over ShareWorker: ğŸ”´ Cloud sees:<br/>ğŸ“Š Access logs, expiry, password hash<br/>âŒ NO encryption keys (in fragment)<br/>âŒ NO plaintext content
    Note over Recipient: ğŸ”‘ Share Key stays in browser/app<br/>ğŸ” Decryption happens client-side
```

**Security Properties:**
- ğŸ”‘ Share key transmitted in URL fragment (never sent to server)
- ğŸ” Document encrypted specifically for sharing (separate from team key)
- ğŸ”’ Optional password protection (hashed, not stored plaintext)
- ğŸ“Š Access logs for audit trail
- ğŸš« **Zero-Knowledge Boundary:** Cloud never sees share key or plaintext
- â° Time-limited share links with expiry

**Share Link Security:**
- âœ… Share key in URL fragment (client-side only)
- âœ… Password protection available
- âœ… Access logging and revocation
- âœ… Client-side decryption (browser or app)
- âŒ Cloud cannot decrypt shared content

**BYOS vs App-Managed:**
- **App-Managed:** Browser decryption via JavaScript
- **BYOS:** Deep link to app (registered users only)

---

## 9. Team Creation Key Distribution

```mermaid
sequenceDiagram
    participant Admin as ğŸŸ¢ Org Admin
    participant PyBackend as ğŸŸ¢ Python Backend
    participant GoAPI as ğŸ”´ Go API
    participant Supabase as ğŸ”´ Supabase
    participant Member as ğŸŸ¢ Team Member

    Note over Admin,PyBackend: ğŸŸ¢ ADMIN'S DEVICE
    Note over GoAPI,Supabase: ğŸ”´ UNTRUSTED CLOUD
    Note over Member: ğŸŸ¢ MEMBER'S DEVICE
    
    Admin->>PyBackend: Create new team "Marketing"
    
    rect rgb(245, 245, 245)
        Note over PyBackend: Team Key Generation
        
        PyBackend->>PyBackend: Generate ğŸ”‘ Team Key<br/>(AES-256 random)
        PyBackend->>PyBackend: Get ğŸ”‘ User Master Key from vault
        PyBackend->>PyBackend: Encrypt for admin<br/>ğŸ” encrypted_team_key = encrypt(ğŸ”‘User Master Key, ğŸ”‘Team Key)
    end
    
    PyBackend->>GoAPI: POST /teams/create<br/>ğŸ“Š {org_id, name, ğŸ”encrypted_team_key_for_admin}
    
    GoAPI->>Supabase: Create team record<br/>ğŸ“Š {id, org_id, name, created_by}
    GoAPI->>Supabase: Store ğŸ” encrypted_team_key in user_team_keys<br/>ğŸ“Š {user_id: admin, team_id, ğŸ”wrapped_key}
    
    Note over Supabase: Stores ğŸ” encrypted team key<br/>ğŸ”‘ Cannot decrypt without user's master key
    
    GoAPI-->>PyBackend: {team_id}
    PyBackend-->>Admin: âœ… Team created
    
    Admin->>PyBackend: Invite member to team
    PyBackend->>GoAPI: POST /teams/{id}/invite<br/>ğŸ“Š {email, role}
    
    GoAPI->>Supabase: Create invitation<br/>ğŸ“Š {team_id, email, role, invited_by}
    GoAPI->>Supabase: Send invite email
    
    rect rgb(240, 242, 245)
        Note over Member: Member Accepts Invitation
        
        Member->>GoAPI: Accept invite (via email link)
        GoAPI->>Supabase: Mark invitation accepted
        GoAPI->>Supabase: Add to team_members<br/>ğŸ“Š {team_id, user_id, role}
        
        Note over Member,PyBackend: Key Distribution
        
        Member->>PyBackend: Login sync teams
        PyBackend->>GoAPI: GET /teams/mine
        GoAPI->>Supabase: Get user's teams
        Supabase-->>GoAPI: ğŸ“Š Teams list (no keys yet)
        GoAPI-->>PyBackend: ğŸ“Š {teams: [{id, name}]}
        
        PyBackend->>GoAPI: Request team key for "Marketing"
        Note over GoAPI: Determine key distribution method
        
        alt Org in Compliance Mode
            Note over GoAPI: Org admins auto-added to teams
            GoAPI->>Supabase: Get admin's ğŸ” encrypted_team_key
            GoAPI-->>PyBackend: ğŸ” encrypted_key (for admin)
            
            PyBackend->>Admin: Request to share key with member
            Admin->>PyBackend: Approve
            
            PyBackend->>PyBackend: Decrypt with admin's ğŸ”‘ Master Key<br/>ğŸ”‘ Team Key = decrypt(ğŸ”‘Admin Master, ğŸ”encrypted_key)
            PyBackend->>PyBackend: Re-encrypt for member<br/>ğŸ” member_wrapped = encrypt(ğŸ”‘Member Master Key, ğŸ”‘Team Key)
            
            PyBackend->>GoAPI: POST /teams/{id}/keys/grant<br/>ğŸ“Š {user_id: member, ğŸ”member_wrapped_key}
            GoAPI->>Supabase: Store ğŸ” encrypted_team_key for member
            
        else Org in Privacy Mode
            Note over GoAPI: Manual key sharing required
            Admin->>PyBackend: Share team key with member
            PyBackend->>PyBackend: Same re-encryption flow
        end
    end
    
    Member->>PyBackend: Fetch my team keys
    PyBackend->>GoAPI: GET /teams/{id}/keys/mine
    GoAPI->>Supabase: Get ğŸ” encrypted_team_key for user
    Supabase-->>GoAPI: ğŸ” user's wrapped key
    GoAPI-->>PyBackend: ğŸ” encrypted_team_key
    
    PyBackend->>PyBackend: Decrypt with ğŸ”‘ User Master Key<br/>ğŸ”‘ Team Key = decrypt(ğŸ”‘User Master, ğŸ”wrapped)
    PyBackend->>PyBackend: Hold ğŸ”‘ Team Key in memory session
    
    PyBackend-->>Member: âœ… Team access granted
    
    Note over Supabase: ğŸ”´ Stores ONLY ğŸ” encrypted team keys<br/>ğŸ”‘ Cannot decrypt without user master keys<br/>ğŸ”‘ Each user has their own wrapped copy
    Note over PyBackend: ğŸŸ¢ Decryption happens locally<br/>ğŸ”‘ Team key in memory only
```

**Security Properties:**
- ğŸ”‘ Team key generated locally by admin
- ğŸ” Team key encrypted separately for each team member (wrapped with their master key)
- ğŸ”‘ Cloud stores only encrypted team keys (per-user wrapped)
- ğŸš« **Zero-Knowledge Boundary:** Cloud cannot decrypt team keys
- ğŸ”’ Privacy Mode: Manual key sharing required
- ğŸ”’ Compliance Mode: Org admins auto-granted access

**Key Distribution Model:**
- âœ… Each user gets their own encrypted copy of team key
- âœ… Wrapped with user's master key (unique per user)
- âœ… Cloud cannot unwrap or access team keys
- âœ… Supports key rotation and revocation

**Privacy vs Compliance Mode:**
- **Privacy Mode:** Org admins not auto-added to teams, manual key sharing
- **Compliance Mode:** Org admins granted access to all team keys for audit purposes

---

## 10. TEE Offload/Load Flow

```mermaid
sequenceDiagram
    participant User
    participant PyBackend as ğŸŸ¢ Python Backend
    participant LocalDBs as ğŸŸ¢ Local DBs
    participant GoAPI as ğŸ”´ Go API
    participant Supabase as ğŸ”´ Supabase
    participant TEE as ğŸŸ¡ TEE Instance<br/>(Confidential VM)
    participant UserCloud as ğŸ”´ User's Cloud<br/>(AWS/Azure/GCP)

    Note over User,LocalDBs: ğŸŸ¢ TRUSTED ZONE
    Note over GoAPI,UserCloud: ğŸ”´ UNTRUSTED INFRASTRUCTURE
    Note over TEE: ğŸŸ¡ SEMI-TRUSTED (Hardware-Protected Enclave)
    
    rect rgb(245, 242, 240)
        Note over User,PyBackend: Threshold Exceeded (500GB+)
        
        PyBackend->>PyBackend: Detect team dataset \u003e 500GB
        PyBackend->>User: âš ï¸ TEE required for team size
        User->>PyBackend: Enable TEE for team
    end
    
    rect rgb(240, 242, 245)
        Note over PyBackend,TEE: TEE Provisioning
        
        PyBackend->>GoAPI: POST /tee/provision<br/>ğŸ“Š {team_id, cloud_provider: "AWS", size: "large"}
        
        GoAPI->>Supabase: Get org's BYO cloud credentials<br/>ğŸ” encrypted creds
        GoAPI->>Supabase: Reserve TEE instance metadata
        
        GoAPI->>UserCloud: Provision confidential VM<br/>(using org's cloud account)
        Note over UserCloud: Org pays cloud costs directly<br/>VM in org's account
        
        UserCloud-->>GoAPI: ğŸ“Š {instance_id, attestation_cert}
        
        GoAPI->>GoAPI: Verify TEE attestation<br/>(ensure genuine secure enclave)
        GoAPI->>Supabase: Store TEE metadata<br/>ğŸ“Š {team_id, instance_id, status: "ready"}
        
        GoAPI-->>PyBackend: âœ… TEE provisioned
    end
    
    rect rgb(242, 242, 240)
        Note over PyBackend,TEE: Secure Data Offload
        
        PyBackend->>PyBackend: Get ğŸ”‘ Team Key from vault
        PyBackend->>LocalDBs: Export Qdrant vectors Neo4j graph
        LocalDBs-->>PyBackend: ğŸ“„ Plaintext index data
        
        PyBackend->>PyBackend: Encrypt for TEE<br/>ğŸ” tee_blob = encrypt(ğŸ”‘TEE Session Key, data)
        Note over PyBackend: TEE Session Key derived from Team Key<br/>+ TEE attestation
        
        PyBackend->>TEE: POST /tee/load<br/>ğŸ” encrypted_index_blob
        Note over TEE: TLS + attestation-based auth
        
        TEE->>TEE: Verify client attestation
        TEE->>TEE: Decrypt with ğŸ”‘ TEE Session Key<br/>ğŸ“„ plaintext = decrypt(ğŸ”blob)
        TEE->>TEE: Load into memory<br/>(Qdrant Neo4j in TEE)
        
        TEE-->>PyBackend: âœ… Data loaded
        
        PyBackend->>LocalDBs: Archive to encrypted_blobs table<br/>ğŸ” cold storage
        PyBackend->>LocalDBs: Clear hot indexes (free memory)
    end
    
    rect rgb(245, 245, 245)
        Note over User,TEE: Search via TEE
        
        User->>PyBackend: Search query
        PyBackend->>PyBackend: Check team data location
        
        alt Data in TEE
            PyBackend->>TEE: POST /search<br/>ğŸ“Š {query, team_id}
            Note over TEE: Mutual TLS + attestation
            
            TEE->>TEE: Hybrid search in TEE memory<br/>(Qdrant + Neo4j)
            TEE-->>PyBackend: ğŸ“„ Search results
            
            PyBackend->>PyBackend: RAG generation (local LLM)
        else Data local
            PyBackend->>LocalDBs: Search locally (as normal)
        end
        
        PyBackend-->>User: Results
    end
    
    rect rgb(243, 245, 243)
        Note over PyBackend,LocalDBs: Load Back to Local
        
        User->>PyBackend: Disable TEE / work locally
        PyBackend->>TEE: POST /tee/export<br/>ğŸ“Š {team_id}
        
        TEE->>TEE: Encrypt data<br/>ğŸ” export_blob = encrypt(ğŸ”‘TEE Session Key, indexes)
        TEE-->>PyBackend: ğŸ” encrypted export
        
        PyBackend->>PyBackend: Decrypt with ğŸ”‘ TEE Session Key
        PyBackend->>LocalDBs: Restore to Qdrant Neo4j
        
        PyBackend->>GoAPI: POST /tee/shutdown<br/>ğŸ“Š {instance_id}
        GoAPI->>UserCloud: Terminate TEE instance
    end
    
    Note over TEE: ğŸŸ¡ Hardware-protected enclave<br/>ğŸ” Data encrypted in transit to/from TEE<br/>ğŸ”‘ Session keys derived from attestation<br/>ğŸš« Cloud provider cannot inspect TEE memory
    Note over GoAPI,Supabase: ğŸ”´ Orchestration only<br/>ğŸ“Š Metadata billing<br/>âŒ NO access to plaintext data
```

**Security Properties:**
- ğŸŸ¡ TEE provides hardware-level confidentiality (encrypted memory)
- ğŸ”‘ Session keys derived from TEE attestation + team key
- ğŸ” Data encrypted during transit to/from TEE
- ğŸ”’ Mutual TLS + attestation for all TEE communication
- ğŸš« **Zero-Knowledge Boundary:** Cloud provider infrastructure cannot access TEE memory
- ğŸ¢ User's cloud account hosts TEE (direct cost control)

**TEE Guarantees:**
- âœ… Hardware-protected confidential computing
- âœ… Attestation proves genuine secure enclave
- âœ… Cloud provider (AWS/Azure/GCP) cannot inspect TEE memory
- âœ… Encrypted communication channels only
- âœ… Data processed in hardware-isolated environment

**Workflow:**
1. **Provision:** Create TEE in user's cloud account
2. **Offload:** Encrypt and transfer data to TEE
3. **Process:** Search/compute runs in TEE enclave
4. **Load:** Transfer data back and shutdown TEE

**When TEE Required:**
- âš ï¸ 50GB: Warning threshold
- ğŸ“Š 100GB: Strong recommendation
- ğŸš« 500GB: Enforced requirement (local hardware insufficient)

---

## Summary: Zero-Knowledge Properties Across All Flows

| Flow | Trusted Zone | Untrusted Zone | What Cloud Sees | What Cloud CANNOT See |
|------|--------------|----------------|-----------------|----------------------|
| **Standalone Mode** | ğŸŸ¢ User's device (all processing) | âŒ N/A (fully offline) | âŒ Nothing | âŒ N/A |
| **App-Managed Upload** | ğŸŸ¢ Local encryption | ğŸ”´ S3, Go API, Supabase | ğŸ” Encrypted blob, ğŸ” encrypted filename, ğŸ“Š metadata | ğŸ“„ Plaintext content, ğŸ“„ plaintext filename, ğŸ”‘ team key |
| **BYOS Upload** | ğŸŸ¢ Local encryption | ğŸ”´ User's bucket, Go API | ğŸ” Encrypted blob, ğŸ” encrypted filename, ğŸ” encrypted credentials | ğŸ“„ Plaintext content, ğŸ”‘ credentials, ğŸ”‘ team key |
| **Search Chat** | ğŸŸ¢ All search LLM processing | ğŸ”´ Optional analytics | ğŸ“Š Query counts, timestamps | ğŸ“„ Query text, ğŸ“„ results, ğŸ“„ document content |
| **Download** | ğŸŸ¢ Client-side decryption | ğŸ”´ S3 serves ciphertext | ğŸ” Encrypted blob download | ğŸ“„ Plaintext content, ğŸ”‘ decryption keys |
| **Share Links** | ğŸŸ¢ Encryption decryption | ğŸ”´ Share worker, metadata | ğŸ“Š Access logs, expiry, password hash | ğŸ”‘ Share key (in URL fragment), ğŸ“„ plaintext content |
| **Team Keys** | ğŸŸ¢ Key generation unwrapping | ğŸ”´ Supabase | ğŸ” Encrypted team keys (per-user wrapped) | ğŸ”‘ Team key plaintext, ğŸ”‘ user master keys |
| **TEE Processing** | ğŸŸ¢ Local backend, ğŸŸ¡ TEE enclave | ğŸ”´ Cloud infrastructure | ğŸ“Š TEE metadata, billing | ğŸ“„ Data in TEE memory (hardware-protected) |

---

## Key Takeaways

1. **ğŸ”‘ Keys Never Leave Trusted Zones**
   - User master keys generated stored locally only
   - Team keys encrypted per-user before cloud storage
   - Share keys transmitted in URL fragments (client-only)

2. **ğŸ” Encryption Before Transmission**
   - All files encrypted with team keys before upload
   - Filenames encrypted and hex-encoded
   - BYOS credentials encrypted with org keys

3. **ğŸš« Zero-Knowledge Cloud**
   - Cloud sees only: encrypted blobs, encrypted filenames, metadata
   - Cloud cannot decrypt without keys (which it never receives)
   - Search and RAG processing stays local

4. **ğŸŸ¡ TEE Semi-Trusted Model**
   - Hardware-protected enclaves for large datasets
   - Attestation-based trust model
   - Cloud infrastructure cannot inspect TEE memory
   - User controls cloud account costs

5. **ğŸ“Š Minimal Metadata Exposure**
   - Cloud receives only necessary operational metadata
   - Anonymized analytics (no query content)
   - Audit logs respect privacy vs compliance mode

6. **ğŸ”’ Defense in Depth**
   - Multiple encryption layers (transport + storage)
   - Mutual TLS + attestation for TEE
   - Time-limited presigned URLs
   - Permission checks before key distribution
